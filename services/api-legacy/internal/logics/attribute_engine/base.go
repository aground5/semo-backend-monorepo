package attribute_engine

import (
	"encoding/json"
	"reflect"
	"semo-server/main/utils"

	"gorm.io/datatypes"
)

// BaseConfig는 모든 엔진에서 공통으로 사용하는 설정 필드를 포함합니다.
type BaseConfig struct {
	DisplayColor    string `json:"display_color,omitempty"`
	AutoGeneratedId string `json:"auto_generated_id,omitempty"`
}

// MergeBase는 BaseConfig 필드를 병합합니다.
func (b *BaseConfig) MergeBase(new BaseConfig) {
	if new.DisplayColor != "" {
		b.DisplayColor = new.DisplayColor
	}
	if new.AutoGeneratedId != "" {
		b.AutoGeneratedId = new.AutoGeneratedId
	}
}

// DisplayInfo는 속성 값의 표시 정보를 정의합니다.
type DisplayInfo struct {
	DisplayValue string      `json:"display_value"`
	DisplayColor string      `json:"display_color"`
	ExtraInfo    interface{} `json:"extra_info,omitempty"`
}

// ConfigValidationResult는 설정 검증 결과를 나타냅니다.
type ConfigValidationResult struct {
	IsValid bool           `json:"is_valid"`
	Errors  []string       `json:"errors,omitempty"`
	Fixed   datatypes.JSON `json:"fixed,omitempty"`
}

// AttributeEngine 인터페이스는 모든 속성 엔진이 구현해야 하는 메서드를 정의합니다.
type AttributeEngine interface {
	// ValidateConfig는 주어진 config를 검증하여 결과를 반환합니다.
	ValidateConfig(config datatypes.JSON) ConfigValidationResult
	// ValidateValue는 주어진 값과 config를 바탕으로 값을 검증하고 정제된 결과를 반환합니다.
	ValidateValue(value string, config datatypes.JSON) (string, error)
	// GetDisplayInfo는 값과 config에 따른 사용자 표시 정보를 반환합니다.
	GetDisplayInfo(value string, config datatypes.JSON) (DisplayInfo, error)
	// MergeConfig은 기존 config와 새로운 config를 병합하여 반환합니다.
	MergeConfig(current, new datatypes.JSON) datatypes.JSON
	// DefaultConfig는 해당 엔진의 기본 config를 반환합니다.
	DefaultConfig() datatypes.JSON
	// TypeName은 엔진의 고유 타입 이름을 반환합니다.
	TypeName() string
}

// StructToJSON은 구조체를 datatypes.JSON으로 변환합니다.
func StructToJSON[T any](obj T) datatypes.JSON {
	b, _ := json.Marshal(obj)
	return b
}

// GenericMergeConfig는 일반적인 구조체의 JSON 설정을 병합합니다.
// 특정 필드 처리 로직이 필요한 경우 customHandler를 사용합니다.
func GenericMergeConfig[T any](current, new datatypes.JSON, customHandler func(curr, newCfg *T)) datatypes.JSON {
	var currCfg T
	var newCfg T
	if err := json.Unmarshal(current, &currCfg); err != nil {
		return current
	}
	if err := json.Unmarshal(new, &newCfg); err != nil {
		return current
	}

	// 기본 타입에 대한 반사 기반 병합
	MergeStructFields(&currCfg, &newCfg)

	// 커스텀 병합 로직이 있으면 실행
	if customHandler != nil {
		customHandler(&currCfg, &newCfg)
	}

	return StructToJSON(currCfg)
}

// GenericMergeConfigSimple은 커스텀 핸들러 없이 구조체를 병합하는 간단한 버전입니다.
func GenericMergeConfigSimple[T any](current, new datatypes.JSON) datatypes.JSON {
	return GenericMergeConfig[T](current, new, nil)
}

// MergeStructFields는 반사(reflection)를 사용하여 구조체 필드를 병합합니다.
// 필드가 기본 타입(문자열, 숫자 등)이고 newStruct의 값이 비어있지 않은 경우 값을 복사합니다.
func MergeStructFields(currStruct, newStruct interface{}) {
	currVal := reflect.ValueOf(currStruct).Elem()
	newVal := reflect.ValueOf(newStruct).Elem()
	currType := currVal.Type()

	for i := 0; i < currVal.NumField(); i++ {
		currField := currVal.Field(i)
		fieldName := currType.Field(i).Name

		// 내장된 구조체 처리 (BaseConfig 등)
		if currType.Field(i).Anonymous {
			if fieldMethod := currVal.Field(i).Addr().MethodByName("MergeBase"); fieldMethod.IsValid() {
				fieldMethod.Call([]reflect.Value{newVal.Field(i)})
				continue
			}
			// 내장 구조체에 MergeBase 메서드가 없으면 일반 필드처럼 처리
			MergeStructFields(currField.Addr().Interface(), newVal.Field(i).Addr().Interface())
			continue
		}

		// 일반 필드 처리
		if !currField.CanSet() {
			continue
		}

		newField := newVal.FieldByName(fieldName)
		if !newField.IsValid() {
			continue
		}

		switch currField.Kind() {
		case reflect.String:
			if newField.String() != "" {
				currField.SetString(newField.String())
			}
		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
			if newField.Int() != 0 {
				currField.SetInt(newField.Int())
			}
		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
			if newField.Uint() != 0 {
				currField.SetUint(newField.Uint())
			}
		case reflect.Float32, reflect.Float64:
			if newField.Float() != 0 {
				currField.SetFloat(newField.Float())
			}
		case reflect.Bool:
			currField.SetBool(newField.Bool())
		case reflect.Ptr:
			if !newField.IsNil() {
				if currField.IsNil() {
					currField.Set(reflect.New(currField.Type().Elem()))
				}
				currField.Elem().Set(newField.Elem())
			}
		}
	}
}

// validateColorString와 validateHex는 utils 패키지의 기능을 호출합니다.
func validateColorString(s string) error {
	return utils.ValidateColorString(s)
}

func validateHex(h string) error {
	return utils.ValidateHex(h)
}
