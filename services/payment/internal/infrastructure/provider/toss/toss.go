package toss

import (
	"bytes"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/wekeepgrowing/semo-backend-monorepo/services/payment/internal/domain/provider"
	"go.uber.org/zap"
)

const (
	tossAPIBaseURL = "https://api.tosspayments.com"
	tossAPIVersion = "v1"
)

// TossProvider implements the PaymentProvider interface for TossPayments
type TossProvider struct {
	secretKey string
	clientKey string
	logger    *zap.Logger
	client    *http.Client
}

// NewTossProvider creates a new TossPayments provider
func NewTossProvider(secretKey, clientKey string, logger *zap.Logger) *TossProvider {
	return &TossProvider{
		secretKey: secretKey,
		clientKey: clientKey,
		logger:    logger,
		client: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

// GetProviderName returns the provider name
func (t *TossProvider) GetProviderName() string {
	return string(provider.ProviderTypeToss)
}

// InitializePayment creates a new payment order with TossPayments
func (t *TossProvider) InitializePayment(ctx context.Context, req *provider.InitializePaymentRequest) (*provider.InitializePaymentResponse, error) {
	t.logger.Info("TossProvider: Initializing payment",
		zap.String("order_id", req.OrderID),
		zap.Int64("amount", req.Amount),
		zap.String("universal_id", req.UniversalID))

	// TossPayments doesn't require server-side initialization for one-time payments
	// The payment is created on the client side and confirmed on the server
	// We'll return the necessary information for client-side processing

	metadata := make(map[string]interface{})

	if req.PlanID != "" {
		metadata["plan_id"] = req.PlanID
	}

	if req.CustomerKey != "" {
		metadata["customer_key"] = req.CustomerKey
	}

	if req.OrderName != "" {
		metadata["order_name"] = req.OrderName
	}
	if req.Currency != "" {
		metadata["currency"] = req.Currency
	}

	if req.Metadata != nil {
		for k, v := range req.Metadata {
			if k == "plan_name" || k == "usage_label" {
				continue
			}
			metadata[k] = v
		}
	}

	return &provider.InitializePaymentResponse{
		OrderID:      req.OrderID,
		PaymentKey:   "",          // Will be generated by Toss client SDK
		ClientSecret: t.clientKey, // Client key for Toss SDK
		Status:       string(provider.PaymentStatusPending),
		Amount:       req.Amount,
		Currency:     req.Currency,
		ProviderData: map[string]interface{}{
			"order_name":   req.OrderName,
			"customer_key": req.CustomerKey,
			"plan_id":      req.PlanID,
			"currency":     req.Currency,
			"metadata":     metadata,
		},
	}, nil
}

// ConfirmPayment confirms and captures a payment with TossPayments
func (t *TossProvider) ConfirmPayment(ctx context.Context, req *provider.ConfirmPaymentRequest) (*provider.ConfirmPaymentResponse, error) {
	t.logger.Info("TossProvider: Confirming payment",
		zap.String("order_id", req.OrderID),
		zap.String("payment_key", req.PaymentKey),
		zap.Int64("amount", req.Amount))

	// Prepare the request body
	confirmReq := map[string]interface{}{
		"paymentKey": req.PaymentKey,
		"orderId":    req.OrderID,
		"amount":     req.Amount,
	}

	body, err := json.Marshal(confirmReq)
	if err != nil {
		t.logger.Error("TossProvider: Failed to marshal confirm request",
			zap.Error(err))
		return nil, &provider.ProviderError{
			Code:    "MARSHAL_ERROR",
			Message: "Failed to prepare confirmation request",
			Details: err.Error(),
		}
	}

	// Create HTTP request
	url := fmt.Sprintf("%s/%s/payments/confirm", tossAPIBaseURL, tossAPIVersion)
	httpReq, err := http.NewRequestWithContext(ctx, "POST", url, bytes.NewBuffer(body))
	if err != nil {
		t.logger.Error("TossProvider: Failed to create HTTP request",
			zap.Error(err))
		return nil, &provider.ProviderError{
			Code:    "REQUEST_ERROR",
			Message: "Failed to create confirmation request",
			Details: err.Error(),
		}
	}

	// Set headers
	auth := base64.StdEncoding.EncodeToString([]byte(t.secretKey + ":"))
	httpReq.Header.Set("Authorization", "Basic "+auth)
	httpReq.Header.Set("Content-Type", "application/json")

	// Execute request
	resp, err := t.client.Do(httpReq)
	if err != nil {
		t.logger.Error("TossProvider: API request failed",
			zap.Error(err))
		return nil, &provider.ProviderError{
			Code:    "API_ERROR",
			Message: "TossPayments API request failed",
			Details: err.Error(),
		}
	}
	defer resp.Body.Close()

	// Read response body
	respBody, err := io.ReadAll(resp.Body)
	if err != nil {
		t.logger.Error("TossProvider: Failed to read response body",
			zap.Error(err))
		return nil, &provider.ProviderError{
			Code:    "RESPONSE_ERROR",
			Message: "Failed to read API response",
			Details: err.Error(),
		}
	}

	// Handle error responses
	if resp.StatusCode != http.StatusOK {
		var errorResp map[string]interface{}
		json.Unmarshal(respBody, &errorResp)

		t.logger.Error("TossProvider: Payment confirmation failed",
			zap.Int("status_code", resp.StatusCode),
			zap.String("response", string(respBody)))

		errorCode, _ := errorResp["code"].(string)
		errorMessage, _ := errorResp["message"].(string)

		return nil, &provider.ProviderError{
			Code:    errorCode,
			Message: errorMessage,
			Details: string(respBody),
		}
	}

	// Parse successful response
	var tossResp map[string]interface{}
	if err := json.Unmarshal(respBody, &tossResp); err != nil {
		t.logger.Error("TossProvider: Failed to parse response",
			zap.Error(err))
		return nil, &provider.ProviderError{
			Code:    "PARSE_ERROR",
			Message: "Failed to parse confirmation response",
			Details: err.Error(),
		}
	}

	// Extract response data
	status := provider.PaymentStatusCompleted
	if tossStatus, ok := tossResp["status"].(string); ok {
		status = mapTossStatus(tossStatus)
	}

	transactionKey, _ := tossResp["transactionKey"].(string)
	method, _ := tossResp["method"].(string)
	currency, _ := tossResp["currency"].(string)

	var paidAt *time.Time
	if approvedAt, ok := tossResp["approvedAt"].(string); ok {
		if t, err := time.Parse(time.RFC3339, approvedAt); err == nil {
			paidAt = &t
		}
	}

	return &provider.ConfirmPaymentResponse{
		OrderID:        req.OrderID,
		PaymentKey:     req.PaymentKey,
		TransactionKey: transactionKey,
		Status:         status,
		Amount:         req.Amount,
		Currency:       currency,
		PaymentMethod:  method,
		PaidAt:         paidAt,
		ProviderData:   tossResp,
	}, nil
}

// HandleWebhook processes TossPayments webhook events
func (t *TossProvider) HandleWebhook(ctx context.Context, payload []byte, signature string) (*provider.WebhookEvent, error) {
	// TODO: Implement webhook signature verification
	// TossPayments uses a different webhook verification method than Stripe

	var webhookData map[string]interface{}
	if err := json.Unmarshal(payload, &webhookData); err != nil {
		t.logger.Error("TossProvider: Failed to parse webhook payload",
			zap.Error(err))
		return nil, &provider.ProviderError{
			Code:    "WEBHOOK_PARSE_ERROR",
			Message: "Failed to parse webhook payload",
			Details: err.Error(),
		}
	}

	var dataMap map[string]interface{}
	if dataField, ok := webhookData["data"]; ok {
		switch v := dataField.(type) {
		case map[string]interface{}:
			dataMap = v
		case []byte:
			if err := json.Unmarshal(v, &dataMap); err != nil {
				t.logger.Warn("TossProvider: Failed to decode data field from bytes",
					zap.Error(err))
			}
		case json.RawMessage:
			if err := json.Unmarshal(v, &dataMap); err != nil {
				t.logger.Warn("TossProvider: Failed to decode data field from raw message",
					zap.Error(err))
			}
		}
	}
	if dataMap == nil {
		dataMap = webhookData
	}

	// Extract event information
	eventType, _ := webhookData["eventType"].(string)
	status := getStringFromMap(dataMap, "status")
	if status == "" {
		status = getStringFromMap(webhookData, "status")
	}
	orderID := getStringFromMap(dataMap, "orderId")
	if orderID == "" {
		orderID = getStringFromMap(webhookData, "orderId")
	}
	paymentKey := getStringFromMap(dataMap, "paymentKey")
	if paymentKey == "" {
		paymentKey = getStringFromMap(webhookData, "paymentKey")
	}
	transactionKey := getStringFromMap(dataMap, "transactionKey")
	if transactionKey == "" {
		transactionKey = getStringFromMap(webhookData, "transactionKey")
	}

	eventID := getStringFromMap(webhookData, "eventId")

	var amount int64
	if amountFloat, ok := dataMap["totalAmount"].(float64); ok {
		amount = int64(amountFloat)
	} else if amountFloat, ok := dataMap["approvedAmount"].(float64); ok {
		amount = int64(amountFloat)
	} else if amountFloat, ok := dataMap["amount"].(float64); ok {
		amount = int64(amountFloat)
	} else if amountFloat, ok := webhookData["amount"].(float64); ok {
		amount = int64(amountFloat)
	}

	createdAt := time.Now()
	if createdAtStr := getStringFromMap(webhookData, "createdAt"); createdAtStr != "" {
		if parsed, err := time.Parse(time.RFC3339, createdAtStr); err == nil {
			createdAt = parsed
		}
	}

	if eventID == "" {
		eventID = fmt.Sprintf("toss_%d", time.Now().UnixNano())
	}

	event := &provider.WebhookEvent{
		EventID:        eventID,
		EventType:      eventType,
		OrderID:        orderID,
		PaymentKey:     paymentKey,
		TransactionKey: transactionKey,
		Status:         status,
		Amount:         amount,
		Data:           dataMap,
		CreatedAt:      createdAt,
	}

	t.logger.Info("TossProvider: Webhook event processed",
		zap.String("event_type", eventType),
		zap.String("order_id", orderID),
		zap.String("status", status))

	return event, nil
}

// mapTossStatus maps TossPayments status to internal PaymentStatus
func mapTossStatus(tossStatus string) provider.PaymentStatus {
	switch tossStatus {
	case "READY", "IN_PROGRESS":
		return provider.PaymentStatusPending
	case "DONE":
		return provider.PaymentStatusCompleted
	case "CANCELED":
		return provider.PaymentStatusCancelled
	case "PARTIAL_CANCELED":
		return provider.PaymentStatusRefunded
	case "ABORTED", "EXPIRED":
		return provider.PaymentStatusFailed
	default:
		return provider.PaymentStatusPending
	}
}

func getStringFromMap(m map[string]interface{}, key string) string {
	if m == nil {
		return ""
	}
	if val, ok := m[key]; ok {
		switch v := val.(type) {
		case string:
			return v
		case fmt.Stringer:
			return v.String()
		case json.Number:
			return v.String()
		}
	}
	return ""
}
