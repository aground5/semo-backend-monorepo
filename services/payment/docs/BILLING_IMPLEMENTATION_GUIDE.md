# 토스페이먼츠 자동결제(빌링) 구현 가이드

> 이 문서는 토스페이먼츠 v2 자동결제 기능을 순차적으로 구현하기 위한 단계별 가이드입니다.

---

## 목차

1. [현재 상태 분석](#1-현재-상태-분석)
2. [사전 준비사항](#2-사전-준비사항)
3. [Phase 1: 데이터베이스 스키마](#phase-1-데이터베이스-스키마)
4. [Phase 2: 암호화 인프라](#phase-2-암호화-인프라)
5. [Phase 3: 빌링키 관리 기능](#phase-3-빌링키-관리-기능)
6. [Phase 4: API 엔드포인트](#phase-4-api-엔드포인트)
7. [Phase 5: 스케줄러 구현](#phase-5-스케줄러-구현)
8. [Phase 6: 웹훅 핸들러 확장](#phase-6-웹훅-핸들러-확장)
9. [Phase 7: 구독 관리 기능](#phase-7-구독-관리-기능)
10. [테스트 가이드](#테스트-가이드)
11. [라이브 전환 체크리스트](#라이브-전환-체크리스트)

---

## 1. 현재 상태 분석

### 구현 완료된 기능

| 기능 | 상태 | 파일 위치 |
|------|------|----------|
| TossProvider 기본 구조 | ✅ | `internal/infrastructure/provider/toss/toss.go` |
| 일회성 결제 초기화/확인 | ✅ | `InitializePayment()`, `ConfirmPayment()` |
| 웹훅 핸들링 (기본) | ✅ | `internal/adapter/handler/http/toss_webhook_handler.go` |
| 결제 상태 매핑 | ✅ | `mapTossStatus()` |
| Subscription 모델 | ✅ | `internal/domain/model/subscription.go` |
| 크레딧 할당 연동 | ✅ | `handlePaymentCompleted()` |
| Provider Factory 패턴 | ✅ | `internal/infrastructure/provider/factory.go` |

### 미구현 기능

| 기능 | 참조 문서 |
|------|----------|
| 빌링키 발급 API | `tosspayments_subscribe.md` 섹션 1.1 |
| 빌링키 암호화 저장 (AES-256-GCM) | `tosspayments_subscribe.md` 섹션 2.1 |
| customerKey 생성/관리 | `tosspayments_subscribe.md` 섹션 1.2 |
| 자동결제 승인 API | `tosspayments_subscribe.md` 섹션 1.4 |
| 결제 스케줄러 | `tosspayments_subscribe.md` 섹션 1.4 |
| 빌링 전용 웹훅 이벤트 처리 | `tosspayments_subscribe.md` 섹션 4.x |

---

## 2. 사전 준비사항

### 개발 환경

```bash
# 필수 환경변수 설정
export PAYMENT_TOSS_SECRET_KEY="test_sk_..."      # 테스트 시크릿 키
export PAYMENT_TOSS_CLIENT_KEY="test_ck_..."      # 테스트 클라이언트 키
export TOSS_BILLING_ENCRYPTION_KEY="<64자리_Hex>" # 빌링키 암호화 키
```

### 암호화 키 생성

```bash
# 64자리 Hex 키 생성 (32바이트 = 256비트)
openssl rand -hex 32
```

### 계약 상태 확인

- [ ] 토스페이먼츠 자동결제 계약 체결 여부 확인
- 미체결 시: 테스트 키로 개발 진행, 라이브 전환 전 계약 필요
- 고객센터: 1544-7772 / support@tosspayments.com

---

## Phase 1: 데이터베이스 스키마

> **목표**: 빌링키 저장, 접근 로그, 스케줄 결제를 위한 테이블 생성

### 1.1 billing_keys 테이블

**파일**: `migrations/011_create_billing_keys.sql`

```sql
-- 빌링키 저장 테이블
CREATE TABLE IF NOT EXISTS billing_keys (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    universal_id UUID NOT NULL,
    customer_key VARCHAR(300) NOT NULL UNIQUE,  -- UUID 형태, 토스 요구사항
    encrypted_billing_key TEXT NOT NULL,         -- AES-256-GCM 암호화된 빌링키
    encryption_iv TEXT NOT NULL,                 -- 초기화 벡터 (매번 랜덤)
    card_last_four VARCHAR(4),                   -- 카드 마지막 4자리 (표시용)
    card_company VARCHAR(50),                    -- 카드사명
    card_type VARCHAR(20),                       -- 신용/체크
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    deactivated_at TIMESTAMP
);

-- 인덱스
CREATE INDEX idx_billing_keys_universal_id ON billing_keys(universal_id);
CREATE INDEX idx_billing_keys_customer_key ON billing_keys(customer_key);
CREATE INDEX idx_billing_keys_active ON billing_keys(is_active) WHERE is_active = TRUE;
```

### 1.2 billing_key_access_logs 테이블

**파일**: `migrations/012_create_billing_key_access_logs.sql`

```sql
-- 빌링키 접근 감사 로그 (개인정보보호법 준수, 2년 보관)
CREATE TABLE IF NOT EXISTS billing_key_access_logs (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    billing_key_id BIGINT NOT NULL,
    access_type VARCHAR(50) NOT NULL,  -- 'encrypt', 'decrypt', 'deactivate'
    accessor_id VARCHAR(100),          -- 시스템 ID 또는 사용자 ID
    ip_address VARCHAR(45),            -- IPv4/IPv6
    user_agent TEXT,
    purpose VARCHAR(255),              -- 접근 목적 (예: 'scheduled_payment', 'manual_charge')
    created_at TIMESTAMP DEFAULT NOW(),

    CONSTRAINT fk_access_logs_billing_key
        FOREIGN KEY (billing_key_id) REFERENCES billing_keys(id)
);

-- 인덱스
CREATE INDEX idx_billing_key_access_logs_billing_key_id ON billing_key_access_logs(billing_key_id);
CREATE INDEX idx_billing_key_access_logs_created_at ON billing_key_access_logs(created_at);
```

### 1.3 scheduled_payments 테이블

**파일**: `migrations/013_create_scheduled_payments.sql`

```sql
-- 예정된 자동결제 스케줄
CREATE TABLE IF NOT EXISTS scheduled_payments (
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    subscription_id BIGINT NOT NULL,
    billing_key_id BIGINT NOT NULL,
    scheduled_at TIMESTAMP NOT NULL,           -- 결제 예정 시각
    amount BIGINT NOT NULL,
    currency VARCHAR(3) DEFAULT 'KRW',
    order_name VARCHAR(255),                   -- 결제 건 이름
    status VARCHAR(20) DEFAULT 'pending',      -- pending, processing, completed, failed, skipped
    attempt_count INT DEFAULT 0,
    last_attempt_at TIMESTAMP,
    last_error TEXT,
    next_retry_at TIMESTAMP,
    completed_at TIMESTAMP,
    payment_id BIGINT,                         -- 성공 시 생성된 payment 레코드 ID
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),

    CONSTRAINT fk_scheduled_payments_billing_key
        FOREIGN KEY (billing_key_id) REFERENCES billing_keys(id),
    CONSTRAINT fk_scheduled_payments_subscription
        FOREIGN KEY (subscription_id) REFERENCES subscriptions(id)
);

-- 인덱스
CREATE INDEX idx_scheduled_payments_scheduled_at ON scheduled_payments(scheduled_at);
CREATE INDEX idx_scheduled_payments_status ON scheduled_payments(status);
CREATE INDEX idx_scheduled_payments_due ON scheduled_payments(status, scheduled_at)
    WHERE status IN ('pending', 'failed');
```

### 완료 체크리스트

- [ ] `011_create_billing_keys.sql` 마이그레이션 실행
- [ ] `012_create_billing_key_access_logs.sql` 마이그레이션 실행
- [ ] `013_create_scheduled_payments.sql` 마이그레이션 실행
- [ ] 테이블 생성 확인

---

## Phase 2: 암호화 인프라

> **목표**: 빌링키를 AES-256-GCM으로 암호화/복호화하는 서비스 구현

### 2.1 암호화 서비스

**파일**: `internal/infrastructure/crypto/encryption.go`

```go
package crypto

import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "encoding/base64"
    "encoding/hex"
    "errors"
    "io"
)

type EncryptionService interface {
    Encrypt(plaintext string) (ciphertext, iv string, err error)
    Decrypt(ciphertext, iv string) (plaintext string, err error)
}

type AESEncryptionService struct {
    key []byte
}

func NewAESEncryptionService(hexKey string) (*AESEncryptionService, error) {
    key, err := hex.DecodeString(hexKey)
    if err != nil {
        return nil, errors.New("invalid encryption key format")
    }
    if len(key) != 32 {
        return nil, errors.New("encryption key must be 32 bytes (64 hex chars)")
    }
    return &AESEncryptionService{key: key}, nil
}

func (s *AESEncryptionService) Encrypt(plaintext string) (string, string, error) {
    block, err := aes.NewCipher(s.key)
    if err != nil {
        return "", "", err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", "", err
    }

    // IV는 매번 랜덤 생성 (KISA 권고)
    iv := make([]byte, gcm.NonceSize())
    if _, err := io.ReadFull(rand.Reader, iv); err != nil {
        return "", "", err
    }

    ciphertext := gcm.Seal(nil, iv, []byte(plaintext), nil)

    return base64.StdEncoding.EncodeToString(ciphertext),
           base64.StdEncoding.EncodeToString(iv),
           nil
}

func (s *AESEncryptionService) Decrypt(ciphertextB64, ivB64 string) (string, error) {
    ciphertext, err := base64.StdEncoding.DecodeString(ciphertextB64)
    if err != nil {
        return "", err
    }

    iv, err := base64.StdEncoding.DecodeString(ivB64)
    if err != nil {
        return "", err
    }

    block, err := aes.NewCipher(s.key)
    if err != nil {
        return "", err
    }

    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return "", err
    }

    plaintext, err := gcm.Open(nil, iv, ciphertext, nil)
    if err != nil {
        return "", err
    }

    return string(plaintext), nil
}
```

### 2.2 설정 확장

**파일**: `internal/config/service.go` (수정)

```go
type TossConfig struct {
    SecretKey     string `mapstructure:"secret_key"`
    ClientKey     string `mapstructure:"client_key"`
    WebhookSecret string `mapstructure:"webhook_secret"`
    PlansFile     string `mapstructure:"plans_file"`
    USDPlansFile  string `mapstructure:"usd_plans_file"`
    EncryptionKey string `mapstructure:"encryption_key"`  // 추가
}
```

**파일**: `configs/payment_legacy.yaml` (수정)

```yaml
service:
  toss:
    secret_key: ${PAYMENT_TOSS_SECRET_KEY}
    client_key: ${PAYMENT_TOSS_CLIENT_KEY}
    encryption_key: ${TOSS_BILLING_ENCRYPTION_KEY}  # 추가
```

### 완료 체크리스트

- [ ] `internal/infrastructure/crypto/encryption.go` 구현
- [ ] `internal/config/service.go`에 `EncryptionKey` 필드 추가
- [ ] `configs/payment_legacy.yaml`에 환경변수 매핑 추가
- [ ] 암호화/복호화 단위 테스트 작성

---

## Phase 3: 빌링키 관리 기능

> **목표**: 빌링키 엔티티, 레포지토리, Provider 확장

### 3.1 도메인 모델

**파일**: `internal/domain/model/billing_key.go`

```go
package model

import (
    "time"
    "github.com/google/uuid"
)

type BillingKey struct {
    ID                  int64      `gorm:"primaryKey;autoIncrement"`
    UniversalID         uuid.UUID  `gorm:"column:universal_id;type:uuid;not null"`
    CustomerKey         string     `gorm:"column:customer_key;uniqueIndex;size:300;not null"`
    EncryptedBillingKey string     `gorm:"column:encrypted_billing_key;type:text;not null"`
    EncryptionIV        string     `gorm:"column:encryption_iv;type:text;not null"`
    CardLastFour        string     `gorm:"column:card_last_four;size:4"`
    CardCompany         string     `gorm:"column:card_company;size:50"`
    CardType            string     `gorm:"column:card_type;size:20"`
    IsActive            bool       `gorm:"column:is_active;default:true"`
    CreatedAt           time.Time  `gorm:"default:now()"`
    UpdatedAt           time.Time  `gorm:"default:now()"`
    DeactivatedAt       *time.Time `gorm:"column:deactivated_at"`
}

func (BillingKey) TableName() string {
    return "billing_keys"
}

type BillingKeyAccessLog struct {
    ID           int64     `gorm:"primaryKey;autoIncrement"`
    BillingKeyID int64     `gorm:"column:billing_key_id;not null"`
    AccessType   string    `gorm:"column:access_type;size:50;not null"`
    AccessorID   string    `gorm:"column:accessor_id;size:100"`
    IPAddress    string    `gorm:"column:ip_address;size:45"`
    UserAgent    string    `gorm:"column:user_agent;type:text"`
    Purpose      string    `gorm:"column:purpose;size:255"`
    CreatedAt    time.Time `gorm:"default:now()"`
}

func (BillingKeyAccessLog) TableName() string {
    return "billing_key_access_logs"
}
```

### 3.2 레포지토리 인터페이스

**파일**: `internal/domain/repository/billing_key_repository.go`

```go
package repository

import (
    "context"
    "github.com/google/uuid"
    "github.com/wekeepgrowing/semo-backend-monorepo/services/payment/internal/domain/model"
)

type BillingKeyRepository interface {
    Create(ctx context.Context, billingKey *model.BillingKey) error
    GetByID(ctx context.Context, id int64) (*model.BillingKey, error)
    GetByCustomerKey(ctx context.Context, customerKey string) (*model.BillingKey, error)
    GetActiveByUniversalID(ctx context.Context, universalID uuid.UUID) ([]*model.BillingKey, error)
    Deactivate(ctx context.Context, id int64) error

    // 접근 로그
    CreateAccessLog(ctx context.Context, log *model.BillingKeyAccessLog) error
}
```

### 3.3 Provider 인터페이스 확장

**파일**: `internal/domain/provider/provider.go` (추가)

```go
// BillingProvider 빌링(자동결제) 관련 인터페이스
type BillingProvider interface {
    // IssueBillingKey 결제창에서 받은 authKey로 빌링키 발급
    IssueBillingKey(ctx context.Context, req *IssueBillingKeyRequest) (*IssueBillingKeyResponse, error)

    // ChargeBillingKey 빌링키로 자동결제 승인 (타임아웃 60초)
    ChargeBillingKey(ctx context.Context, req *ChargeBillingKeyRequest) (*ChargeBillingKeyResponse, error)
}

type IssueBillingKeyRequest struct {
    AuthKey     string `json:"auth_key"`
    CustomerKey string `json:"customer_key"`
}

type IssueBillingKeyResponse struct {
    BillingKey   string `json:"billing_key"`
    CustomerKey  string `json:"customer_key"`
    CardCompany  string `json:"card_company"`
    CardNumber   string `json:"card_number"`   // 마스킹된 카드번호
    CardType     string `json:"card_type"`     // 신용/체크
}

type ChargeBillingKeyRequest struct {
    BillingKey  string `json:"billing_key"`
    CustomerKey string `json:"customer_key"`
    Amount      int64  `json:"amount"`
    OrderID     string `json:"order_id"`
    OrderName   string `json:"order_name"`
}

type ChargeBillingKeyResponse struct {
    PaymentKey     string     `json:"payment_key"`
    OrderID        string     `json:"order_id"`
    Status         string     `json:"status"`
    Amount         int64      `json:"amount"`
    ApprovedAt     *time.Time `json:"approved_at"`
    TransactionKey string     `json:"transaction_key"`
}
```

### 3.4 Toss 빌링 API 구현

**파일**: `internal/infrastructure/provider/toss/billing.go`

```go
package toss

import (
    "bytes"
    "context"
    "encoding/base64"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "time"

    "github.com/wekeepgrowing/semo-backend-monorepo/services/payment/internal/domain/provider"
    "go.uber.org/zap"
)

// IssueBillingKey POST /v1/billing/authorizations/issue
func (t *TossProvider) IssueBillingKey(ctx context.Context, req *provider.IssueBillingKeyRequest) (*provider.IssueBillingKeyResponse, error) {
    url := fmt.Sprintf("%s/%s/billing/authorizations/issue", tossAPIBaseURL, tossAPIVersion)

    body := map[string]string{
        "authKey":     req.AuthKey,
        "customerKey": req.CustomerKey,
    }

    jsonBody, _ := json.Marshal(body)
    httpReq, _ := http.NewRequestWithContext(ctx, "POST", url, bytes.NewBuffer(jsonBody))

    auth := base64.StdEncoding.EncodeToString([]byte(t.secretKey + ":"))
    httpReq.Header.Set("Authorization", "Basic "+auth)
    httpReq.Header.Set("Content-Type", "application/json")

    resp, err := t.client.Do(httpReq)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    respBody, _ := io.ReadAll(resp.Body)

    if resp.StatusCode != http.StatusOK {
        var errResp map[string]interface{}
        json.Unmarshal(respBody, &errResp)
        return nil, &provider.ProviderError{
            Code:    errResp["code"].(string),
            Message: errResp["message"].(string),
        }
    }

    var result provider.IssueBillingKeyResponse
    json.Unmarshal(respBody, &result)

    return &result, nil
}

// ChargeBillingKey POST /v1/billing/{billingKey}
func (t *TossProvider) ChargeBillingKey(ctx context.Context, req *provider.ChargeBillingKeyRequest) (*provider.ChargeBillingKeyResponse, error) {
    url := fmt.Sprintf("%s/%s/billing/%s", tossAPIBaseURL, tossAPIVersion, req.BillingKey)

    body := map[string]interface{}{
        "customerKey": req.CustomerKey,
        "amount":      req.Amount,
        "orderId":     req.OrderID,
        "orderName":   req.OrderName,
    }

    jsonBody, _ := json.Marshal(body)

    // 자동결제는 최대 60초 소요 가능
    client := &http.Client{Timeout: 60 * time.Second}
    httpReq, _ := http.NewRequestWithContext(ctx, "POST", url, bytes.NewBuffer(jsonBody))

    auth := base64.StdEncoding.EncodeToString([]byte(t.secretKey + ":"))
    httpReq.Header.Set("Authorization", "Basic "+auth)
    httpReq.Header.Set("Content-Type", "application/json")

    resp, err := client.Do(httpReq)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    respBody, _ := io.ReadAll(resp.Body)

    if resp.StatusCode != http.StatusOK {
        var errResp map[string]interface{}
        json.Unmarshal(respBody, &errResp)
        return nil, &provider.ProviderError{
            Code:    errResp["code"].(string),
            Message: errResp["message"].(string),
        }
    }

    var result provider.ChargeBillingKeyResponse
    json.Unmarshal(respBody, &result)

    return &result, nil
}
```

### 완료 체크리스트

- [ ] `internal/domain/model/billing_key.go` 구현
- [ ] `internal/domain/repository/billing_key_repository.go` 인터페이스 정의
- [ ] `internal/adapter/repository/billing_key_repository.go` 구현
- [ ] `internal/domain/provider/provider.go`에 BillingProvider 추가
- [ ] `internal/infrastructure/provider/toss/billing.go` 구현

---

## Phase 4: API 엔드포인트

> **목표**: 빌링키 발급, 조회, 비활성화 API 구현

### 4.1 빌링 서비스

**파일**: `internal/usecase/billing_service.go`

```go
package usecase

import (
    "context"
    "github.com/google/uuid"
    "github.com/wekeepgrowing/semo-backend-monorepo/services/payment/internal/domain/model"
    "github.com/wekeepgrowing/semo-backend-monorepo/services/payment/internal/domain/repository"
    "github.com/wekeepgrowing/semo-backend-monorepo/services/payment/internal/infrastructure/crypto"
    "github.com/wekeepgrowing/semo-backend-monorepo/services/payment/internal/infrastructure/provider/toss"
)

type BillingService struct {
    billingKeyRepo repository.BillingKeyRepository
    tossProvider   *toss.TossProvider
    encryptService crypto.EncryptionService
}

func (s *BillingService) IssueBillingKey(
    ctx context.Context,
    universalID uuid.UUID,
    authKey string,
    ipAddress string,
    userAgent string,
) (*model.BillingKey, error) {
    // 1. customerKey 생성 (UUID 형태)
    customerKey := uuid.New().String()

    // 2. 토스 API로 빌링키 발급
    resp, err := s.tossProvider.IssueBillingKey(ctx, &provider.IssueBillingKeyRequest{
        AuthKey:     authKey,
        CustomerKey: customerKey,
    })
    if err != nil {
        return nil, err
    }

    // 3. 빌링키 암호화
    encryptedKey, iv, err := s.encryptService.Encrypt(resp.BillingKey)
    if err != nil {
        return nil, err
    }

    // 4. DB 저장
    billingKey := &model.BillingKey{
        UniversalID:         universalID,
        CustomerKey:         customerKey,
        EncryptedBillingKey: encryptedKey,
        EncryptionIV:        iv,
        CardLastFour:        resp.CardNumber[len(resp.CardNumber)-4:],
        CardCompany:         resp.CardCompany,
        CardType:            resp.CardType,
        IsActive:            true,
    }

    if err := s.billingKeyRepo.Create(ctx, billingKey); err != nil {
        return nil, err
    }

    // 5. 접근 로그 기록
    s.billingKeyRepo.CreateAccessLog(ctx, &model.BillingKeyAccessLog{
        BillingKeyID: billingKey.ID,
        AccessType:   "encrypt",
        AccessorID:   "system",
        IPAddress:    ipAddress,
        UserAgent:    userAgent,
        Purpose:      "billing_key_issue",
    })

    return billingKey, nil
}

func (s *BillingService) GetCards(ctx context.Context, universalID uuid.UUID) ([]*model.BillingKey, error) {
    return s.billingKeyRepo.GetActiveByUniversalID(ctx, universalID)
}

func (s *BillingService) DeactivateCard(ctx context.Context, id int64, ipAddress, userAgent string) error {
    // 접근 로그 기록
    s.billingKeyRepo.CreateAccessLog(ctx, &model.BillingKeyAccessLog{
        BillingKeyID: id,
        AccessType:   "deactivate",
        AccessorID:   "user",
        IPAddress:    ipAddress,
        UserAgent:    userAgent,
        Purpose:      "user_request",
    })

    return s.billingKeyRepo.Deactivate(ctx, id)
}
```

### 4.2 HTTP 핸들러

**파일**: `internal/adapter/handler/http/billing_handler.go`

```go
package http

import (
    "net/http"
    "strconv"

    "github.com/google/uuid"
    "github.com/labstack/echo/v4"
    "github.com/wekeepgrowing/semo-backend-monorepo/services/payment/internal/usecase"
)

type BillingHandler struct {
    billingService *usecase.BillingService
}

// POST /api/v1/billing/issue
func (h *BillingHandler) IssueBillingKey(c echo.Context) error {
    var req struct {
        AuthKey string `json:"auth_key" validate:"required"`
    }
    if err := c.Bind(&req); err != nil {
        return c.JSON(http.StatusBadRequest, echo.Map{"error": "invalid request"})
    }

    universalID := c.Get("universal_id").(uuid.UUID)
    ipAddress := c.RealIP()
    userAgent := c.Request().UserAgent()

    billingKey, err := h.billingService.IssueBillingKey(
        c.Request().Context(),
        universalID,
        req.AuthKey,
        ipAddress,
        userAgent,
    )
    if err != nil {
        return c.JSON(http.StatusInternalServerError, echo.Map{"error": err.Error()})
    }

    return c.JSON(http.StatusOK, echo.Map{
        "id":            billingKey.ID,
        "card_last_four": billingKey.CardLastFour,
        "card_company":  billingKey.CardCompany,
        "card_type":     billingKey.CardType,
    })
}

// GET /api/v1/billing/cards
func (h *BillingHandler) GetCards(c echo.Context) error {
    universalID := c.Get("universal_id").(uuid.UUID)

    cards, err := h.billingService.GetCards(c.Request().Context(), universalID)
    if err != nil {
        return c.JSON(http.StatusInternalServerError, echo.Map{"error": err.Error()})
    }

    result := make([]map[string]interface{}, len(cards))
    for i, card := range cards {
        result[i] = map[string]interface{}{
            "id":            card.ID,
            "card_last_four": card.CardLastFour,
            "card_company":  card.CardCompany,
            "card_type":     card.CardType,
            "created_at":    card.CreatedAt,
        }
    }

    return c.JSON(http.StatusOK, echo.Map{"cards": result})
}

// DELETE /api/v1/billing/cards/:id
func (h *BillingHandler) DeactivateCard(c echo.Context) error {
    id, _ := strconv.ParseInt(c.Param("id"), 10, 64)
    ipAddress := c.RealIP()
    userAgent := c.Request().UserAgent()

    if err := h.billingService.DeactivateCard(
        c.Request().Context(),
        id,
        ipAddress,
        userAgent,
    ); err != nil {
        return c.JSON(http.StatusInternalServerError, echo.Map{"error": err.Error()})
    }

    return c.JSON(http.StatusOK, echo.Map{"status": "deactivated"})
}
```

### 4.3 라우트 등록

**파일**: `internal/infrastructure/http/server.go` (수정)

```go
// 빌링 관련 라우트 추가
billing := api.Group("/billing")
billing.POST("/issue", billingHandler.IssueBillingKey)
billing.GET("/cards", billingHandler.GetCards)
billing.DELETE("/cards/:id", billingHandler.DeactivateCard)
```

### 완료 체크리스트

- [ ] `internal/usecase/billing_service.go` 구현
- [ ] `internal/adapter/handler/http/billing_handler.go` 구현
- [ ] `internal/infrastructure/http/server.go`에 라우트 등록
- [ ] API 테스트 (Postman/curl)

---

## Phase 5: 스케줄러 구현

> **목표**: 매 시간 자동결제를 처리하는 내장 스케줄러 구현

### 5.1 결제 스케줄러 서비스

**파일**: `internal/usecase/scheduler/billing_scheduler.go`

```go
package scheduler

import (
    "context"
    "time"

    "github.com/wekeepgrowing/semo-backend-monorepo/services/payment/internal/domain/model"
    "github.com/wekeepgrowing/semo-backend-monorepo/services/payment/internal/domain/repository"
    "github.com/wekeepgrowing/semo-backend-monorepo/services/payment/internal/infrastructure/crypto"
    "github.com/wekeepgrowing/semo-backend-monorepo/services/payment/internal/infrastructure/provider/toss"
    "go.uber.org/zap"
)

type BillingScheduler struct {
    billingKeyRepo   repository.BillingKeyRepository
    scheduledRepo    repository.ScheduledPaymentRepository
    paymentRepo      repository.PaymentRepository
    tossProvider     *toss.TossProvider
    encryptService   crypto.EncryptionService
    logger           *zap.Logger
}

// ProcessDuePayments 예정된 결제 처리
func (s *BillingScheduler) ProcessDuePayments(ctx context.Context) error {
    // scheduled_at <= NOW() AND status = 'pending' 조회
    duePayments, err := s.scheduledRepo.GetDuePayments(ctx)
    if err != nil {
        return err
    }

    s.logger.Info("Processing due payments", zap.Int("count", len(duePayments)))

    for _, scheduled := range duePayments {
        if err := s.processPayment(ctx, scheduled); err != nil {
            s.logger.Error("Failed to process scheduled payment",
                zap.Int64("scheduled_id", scheduled.ID),
                zap.Error(err))
        }
    }

    return nil
}

func (s *BillingScheduler) processPayment(ctx context.Context, scheduled *model.ScheduledPayment) error {
    // 1. 상태를 processing으로 변경
    s.scheduledRepo.UpdateStatus(ctx, scheduled.ID, "processing")

    // 2. 빌링키 조회 및 복호화
    billingKey, err := s.billingKeyRepo.GetByID(ctx, scheduled.BillingKeyID)
    if err != nil {
        return s.handleFailure(ctx, scheduled, err.Error())
    }

    decryptedKey, err := s.encryptService.Decrypt(
        billingKey.EncryptedBillingKey,
        billingKey.EncryptionIV,
    )
    if err != nil {
        return s.handleFailure(ctx, scheduled, "decryption_failed")
    }

    // 접근 로그 기록
    s.billingKeyRepo.CreateAccessLog(ctx, &model.BillingKeyAccessLog{
        BillingKeyID: billingKey.ID,
        AccessType:   "decrypt",
        AccessorID:   "scheduler",
        Purpose:      "scheduled_payment",
    })

    // 3. 토스 API 호출
    resp, err := s.tossProvider.ChargeBillingKey(ctx, &provider.ChargeBillingKeyRequest{
        BillingKey:  decryptedKey,
        CustomerKey: billingKey.CustomerKey,
        Amount:      scheduled.Amount,
        OrderID:     generateOrderID(),
        OrderName:   scheduled.OrderName,
    })
    if err != nil {
        return s.handleFailure(ctx, scheduled, err.Error())
    }

    // 4. 성공 처리
    return s.handleSuccess(ctx, scheduled, resp)
}

func (s *BillingScheduler) handleFailure(ctx context.Context, scheduled *model.ScheduledPayment, errMsg string) error {
    scheduled.AttemptCount++
    scheduled.LastError = errMsg
    scheduled.LastAttemptAt = time.Now()

    // 최대 5회 재시도
    if scheduled.AttemptCount >= 5 {
        scheduled.Status = "failed"
        // TODO: 사용자 알림, 구독 일시정지
    } else {
        // 지수 백오프: 1h, 2h, 4h, 8h, 24h
        backoff := time.Duration(1<<scheduled.AttemptCount) * time.Hour
        if backoff > 24*time.Hour {
            backoff = 24 * time.Hour
        }
        scheduled.NextRetryAt = time.Now().Add(backoff)
        scheduled.Status = "pending" // 재시도 대기
    }

    return s.scheduledRepo.Update(ctx, scheduled)
}

func (s *BillingScheduler) handleSuccess(ctx context.Context, scheduled *model.ScheduledPayment, resp *provider.ChargeBillingKeyResponse) error {
    scheduled.Status = "completed"
    scheduled.CompletedAt = time.Now()
    // scheduled.PaymentID = 생성된 payment 레코드 ID

    return s.scheduledRepo.Update(ctx, scheduled)
}

// ScheduleNextPayment 다음 결제 스케줄 생성
func (s *BillingScheduler) ScheduleNextPayment(ctx context.Context, subscriptionID int64, billingKeyID int64, amount int64, nextDate time.Time) error {
    scheduled := &model.ScheduledPayment{
        SubscriptionID: subscriptionID,
        BillingKeyID:   billingKeyID,
        ScheduledAt:    nextDate,
        Amount:         amount,
        Status:         "pending",
    }
    return s.scheduledRepo.Create(ctx, scheduled)
}
```

### 5.2 Cron 스케줄러 래퍼

**파일**: `internal/infrastructure/scheduler/cron.go`

```go
package scheduler

import (
    "context"

    "github.com/robfig/cron/v3"
    usecaseScheduler "github.com/wekeepgrowing/semo-backend-monorepo/services/payment/internal/usecase/scheduler"
    "go.uber.org/zap"
)

type CronScheduler struct {
    cron             *cron.Cron
    billingScheduler *usecaseScheduler.BillingScheduler
    logger           *zap.Logger
}

func NewCronScheduler(billingScheduler *usecaseScheduler.BillingScheduler, logger *zap.Logger) *CronScheduler {
    return &CronScheduler{
        cron:             cron.New(),
        billingScheduler: billingScheduler,
        logger:           logger,
    }
}

func (s *CronScheduler) Start() error {
    // 매 시간 정각에 실행 (0 * * * *)
    _, err := s.cron.AddFunc("0 * * * *", func() {
        s.logger.Info("Running scheduled payment processor")
        ctx := context.Background()
        if err := s.billingScheduler.ProcessDuePayments(ctx); err != nil {
            s.logger.Error("Failed to process due payments", zap.Error(err))
        }
    })
    if err != nil {
        return err
    }

    s.cron.Start()
    s.logger.Info("Billing scheduler started", zap.String("schedule", "0 * * * *"))
    return nil
}

func (s *CronScheduler) Stop() {
    ctx := s.cron.Stop()
    <-ctx.Done()
    s.logger.Info("Billing scheduler stopped")
}
```

### 5.3 서버 통합

**파일**: `cmd/server/main.go` (수정)

```go
// 스케줄러 시작
cronScheduler := scheduler.NewCronScheduler(billingScheduler, logger)
if err := cronScheduler.Start(); err != nil {
    logger.Fatal("Failed to start scheduler", zap.Error(err))
}

// Graceful shutdown에 스케줄러 종료 추가
defer cronScheduler.Stop()
```

### 완료 체크리스트

- [ ] `internal/usecase/scheduler/billing_scheduler.go` 구현
- [ ] `internal/infrastructure/scheduler/cron.go` 구현
- [ ] `cmd/server/main.go`에 스케줄러 통합
- [ ] `go get github.com/robfig/cron/v3` 의존성 추가
- [ ] 스케줄러 테스트

---

## Phase 6: 웹훅 핸들러 확장

> **목표**: 빌링 관련 웹훅 이벤트 처리

### 6.1 빌링 이벤트 처리 추가

**파일**: `internal/adapter/handler/http/toss_webhook_handler.go` (수정)

```go
// Handle 메서드에 빌링 이벤트 처리 추가
switch event.EventType {
case "BILLING_KEY_ISSUED":
    // 빌링키 발급 완료 확인
    h.logger.Info("Billing key issued via webhook",
        zap.String("customer_key", event.Data["customerKey"].(string)))

case "BILLING_KEY_DELETED":
    // 빌링키 삭제됨 - 내부 상태 동기화
    customerKey := event.Data["customerKey"].(string)
    // billingKeyRepo.DeactivateByCustomerKey(ctx, customerKey)

// 기존 결제 상태 처리...
}
```

### 6.2 빌링 에러 코드 처리

```go
// handlePaymentFailed에 빌링 관련 에러 코드 추가
switch failureCode {
case "NOT_MATCHES_CUSTOMER_KEY":
    failureMessage = "customerKey와 billingKey가 일치하지 않습니다"
case "BILLING_KEY_ALREADY_DELETED":
    failureMessage = "삭제된 빌링키입니다. 새로운 결제수단을 등록해주세요"
case "INVALID_CARD_EXPIRATION":
    failureMessage = "카드 유효기간이 만료되었습니다"
case "REJECT_CARD_COMPANY":
    failureMessage = "카드사에서 거절되었습니다. 카드사에 문의하거나 다른 결제수단을 사용해주세요"
}
```

### 완료 체크리스트

- [ ] `toss_webhook_handler.go`에 빌링 이벤트 처리 추가
- [ ] 빌링 관련 에러 코드 메시지 정의
- [ ] 웹훅 테스트

---

## Phase 7: 구독 관리 기능

> **목표**: 구독 취소, 결제수단 변경, 플랜 변경 기능

### 7.1 구독 취소

```go
// 구독 취소 시 빌링키는 유지, 스케줄만 중단
func (s *SubscriptionService) CancelSubscription(ctx context.Context, subscriptionID int64) error {
    // 1. Subscription.CanceledAt 설정
    // 2. 예정된 scheduled_payments를 'skipped'로 변경
    // 3. 빌링키는 유지 (재개 가능)
}
```

### 7.2 결제수단 변경

```go
func (s *SubscriptionService) ChangePaymentMethod(ctx context.Context, subscriptionID int64, newBillingKeyID int64) error {
    // 1. 기존 빌링키 비활성화 (선택적)
    // 2. 구독에 새 빌링키 연결
    // 3. 예정된 scheduled_payments의 billing_key_id 업데이트
}
```

### 7.3 플랜 변경

```go
func (s *SubscriptionService) ChangePlan(ctx context.Context, subscriptionID int64, newPlanID string) error {
    // 1. 새 플랜의 금액/주기 조회
    // 2. 예정된 scheduled_payments의 amount 업데이트
    // 3. 주기 변경 시 다음 결제일 재계산
}
```

### 완료 체크리스트

- [ ] 구독 취소 로직 구현
- [ ] 결제수단 변경 API 구현
- [ ] 플랜 변경 로직 구현

---

## 테스트 가이드

### 테스트 환경 설정

```bash
# 테스트 키 사용
export PAYMENT_TOSS_SECRET_KEY="test_sk_..."
export PAYMENT_TOSS_CLIENT_KEY="test_ck_..."
```

### 빌링키 발급 테스트

1. 클라이언트에서 토스 SDK로 결제창 호출
2. 테스트 카드 정보 입력 (BIN 6자리만 유효하면 됨)
3. 발급된 `authKey`로 `/api/v1/billing/issue` 호출
4. 응답 확인

### 자동결제 테스트

1. 빌링키 발급 후 scheduled_payments에 테스트 레코드 생성
2. 스케줄러 수동 실행 또는 scheduled_at을 현재 시각으로 설정
3. 결제 결과 확인

---

## 라이브 전환 체크리스트

### 계약 및 인증

- [ ] 토스페이먼츠 자동결제 계약 완료 (1544-7772)
- [ ] 실서비스 MID 발급 확인
- [ ] 실서비스 클라이언트 키/시크릿 키 발급
- [ ] 환경변수를 실서비스 키로 변경

### 보안

- [ ] 빌링키 AES-256-GCM 암호화 확인
- [ ] IV 매번 랜덤 생성 확인
- [ ] 암호화 키 환경변수 관리
- [ ] 시크릿 키 서버 사이드 전용 확인
- [ ] 접근 로그 2년 보관 정책 설정
- [ ] HTTPS 통신 확인

### 법적 준수

- [ ] 개인정보 처리방침에 빌링키 저장 명시
- [ ] 이용약관에 구독 조항 추가
- [ ] 사용자 동의 획득 프로세스 확인

### 시스템

- [ ] 테스트 데이터 삭제
- [ ] 모니터링 설정 (에러 알림, 결제 실패 알림)
- [ ] 백업 시스템 확인
- [ ] 롤백 계획 수립

---

## 참고 문서

- [토스페이먼츠 v2 자동결제 가이드](./tosspayments_subscribe.md)
- [토스페이먼츠 공식 문서](https://docs.tosspayments.com/guides/v2/billing)
- [API 레퍼런스](https://docs.tosspayments.com/reference)
- [에러 코드](https://docs.tosspayments.com/reference#에러-코드)
